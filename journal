2024-06-01: UART read/write timing fix (part 2)
===============================================

The circuitry updated on May 27 was tested, and unfortunately does not work.
This is because the ADDR_C1 (and thus, /CS0) signal is not stable across
SEQ increments, and neither is /WRAM, and neither are ADDR0/ADDR1.
The /WRAM signal can also flap (but not nearly as bad).  The DATA lines
can flap too, between seqences. So to create the proper "slow" signaling,
it's going to require adding some D flip-flops to gate the /CS0, /RD, /WR,
ADDR0, and ADDR1 signals.

The patchwork that ended up finally working was to bodge in a 74HC377 where
six of its eight flip flops could be accessed.  Five of these flip flops are
used to store ADDR0, ADDR1, ADDR_C1, /RDGEN, and /WRGEN. /RDGEN and /WRGEN
depend on the latched output of the ADDR_C1 flip-flop, and thus will always
be one clock behind (as expected).

There is still one more flip-flop available, which can be used to latch
ADDR2 if needed for some other slow device.  And there are still two more
flip-flops available, but they'd require soldering some wires to wrap pins.

All said, this succeeds at getting the serial console working again, with
the faster asymmetric clock.  And it eliminates the race condition between
the UART timing and the system clock.

However, much to my disappointment, processing long streams of text in
the console program still triggers crashes.  This is still the case even
with the CPU clocked as low as 1MHz. So it must be a coding bug (perhaps
something in the scrolling routines?)


2024-05-27: UART read/write timing fix
======================================

The problem boils down to the need for the data/address to be stable when
/RD or /WR go low, and must _stay_ stable when /RD or /WR go high. To accomplish
this, some "slow" LD (read) and ST/ALUOP_ADDR (write) opcodes will be created,
which include an extra setup step in sequence 0x4, then perform the desired
operation in sequence 0x5, and then continue holding the addr/data into
sequence 0x6 before moving to the next instruction.

This allows the /RD and /WR signals to be controlled by the sequence counter,
not the clock. The sequence counter's transition from 0b0100 to 0b0101 should
not cause any glitches due to just one bit having to transition, so the initial
/RD / /WR assertion will be well coordinated and take place very shortly after
the rising clock edge.  The transition from 0b0101 to 0b0110 could glitch, but
the only glitch state would be 0b0111, which still results in the desired
behavior of the signal being de-asserted.  Thus /RD or /WR would not be
re-asserted in a glitch at the end of sequence 0x5.

The logisim/uart_glue_logic.circ schematic shows how the 4-input NOR gate in
group C G-J can be used to generate the SEQ5 signal.  Two inverters will be
needed to generate the inputs for the 4-in NOR gate.  There is sufficient board
space in group D C-D for a hex inverter.

The existing quad NAND gate in group F E-F can be reused as it is already
generating the /RD and /WR signals.

F26-F27 gate needs F27 changed to the SEQ5 signal
F29-F30 gate can stay the same
E25-E26 gate can stay the same
E28-E29 gate can stay the same

The wiring was completed and the control ROMs updated.  New _SLOW opcodes
have been created in the 0xaN opcode range. The UART library has been
updated to use these opcodes.

However, when running the console command, it's not working, and the
system hangs when sending a character.  It's likely locked in a loop
waiting for the acknowledgement that the character was sent.

Need to do a few things next:
  1. Create `peek-slow` and `poke-slow` shell commands
  2. Update logic analyzer with new _SLOW opcodes in symbol table
  3. Probe the /RD and /WR signals on the UART to verify timings
  4. Check for lingering places where non-SLOW opcodes are used
     to talk to the UART - regular reads/writes won't work at all
     because /RD and /WR are now gated on the SEQ5 signal, not
     the clock.


