# [opcode] NAME <arguments> - @arg = 16bit $arg = 8bit
#   opcode is the hexadecimal opcode, 0x00 - 0xff
#   NAME is the assembler name
#   arguments is a list of expected bytes after the opcode in the program,
#   @arg represents a 16-bit value (2 bytes), $arg represents an 8-bit
#   value (1 byte).
#
#   The microcode is written as a series of control sequences.  Each line
#   starts with one or two characters, (x,e,E,z,Z,f,F) that indicate that this
#   microcode entry should be executed for any flags (x), when the equal
#   flag is set (E) or clear (e), or the zero flag is set (Z) or clear (z),
#   or the overflow flag is set (F) or clear (f), or a combination (eZ, ZE),
#   etc.  A missing character means its value does not matter.  If neither
#   e nor z nor f matter, then "x" is a stand-in for "no status bits matter".
#
#   After this comes the sequence number,
#   from 0-f.  After this is a list of macros that will be
#   ORed to form the control signals for this microcode entry.

###### Phase 1 ######
# Program counter
# ROM (0x0000-0x3fff)
# RAM (0x4000-0xbfff)
# Opcode register + Status register + Sequence counter 
# Transfer registers
# Control ROMs

# No-op: does nothing
[0x00] NOP
x 0 IncrementPC 
x 1 NextInstruction

# Halt: goes into infinite loop of loading the program
# counter address into the opcode register, but never
# incrementing the program counter.  So the CPU just
# runs HLT in an endless loop.
[0xff] HLT
x 0 NextInstruction

# Store to RAM: store the specified byte at
# the given address.
[0x10] ST @addr $data
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to data byte
x 3 AddrBusPC WriteTD IncrementPC
x 4 AddrBusTA DataBusTD WriteRAM
x 5 NextInstruction

# Store to RAM from TD register
[0x11] ST_TD @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA DataBusTD WriteRAM
x 4 NextInstruction

# Load from RAM to TD register
[0x20] LD_TD @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteTD
x 4 NextInstruction

# Jump: unconditional jump to specified address
[0x30] JMP @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
x 2 AddrBusPC WritePCL
x 3 DataBusTD WritePCH
x 4 NextInstruction

# Push: put a static value on the stack
[0x40] PUSH $data
x 0 IncrementPC IncrementSP
# PC now points to data; SP points to target address
x 1 AddrBusPC WriteTD
# TD now contains the data to be written to the stack
x 2 AddrBusSP DataBusTD WriteRAM IncrementPC
# PC now points to next instruction
x 3 NextInstruction

# Push TD onto the stack
[0x41] PUSH_TD
x 0 IncrementPC IncrementSP
# PC now points to next instruction; SP points to target address
x 1 AddrBusSP DataBusTD WriteRAM # write TD to stack
x 2 NextInstruction

# Peek: fetch the data from the top of the stack
# into TD, but don't remove it
[0x48] PEEK_TD
x 0 AddrBusSP WriteTD IncrementPC
x 1 NextInstruction

# Pop into TD
[0x49] POP_TD
x 0 AddrBusSP WriteTD DecrementSP IncrementPC
x 1 NextInstruction

# Call subroutine: push next instruction address onto
# the stack, then jump to the given address
[0x50] CALL @addr
x 0 IncrementPC
# PC now points to high byte of subroutine address;
# Write high byte to TAL (TAL can present to data bus)
x 1 AddrBusPC WriteTAL IncrementPC
# PC now points to low byte of subroute address;
# Write low byte to TD
x 2 AddrBusPC WriteTD IncrementPC IncrementSP
# PC now points to next instruction address;
# Write low byte to stack
x 3 AddrBusSP DataBusPCL WriteRAM IncrementSP
# Write high byte to stack
x 4 AddrBusSP DataBusPCH WriteRAM
# Load next instruction address from TAL & TD
x 5 DataBusTAL WritePCH
x 6 DataBusTD WritePCL
x 7 NextInstruction

# Return from subroutine: pop the next instruction
# address from the stack, jump to that address
[0x5f] RET
x 0 AddrBusSP WritePCH DecrementSP
x 1 AddrBusSP WritePCL DecrementSP
x 2 NextInstruction

###### Phase 2 ######
# AH/AL + BH/BL registers
# ALU

# Store immediate word into A
[0x60] LDI_A @word
x 0 IncrementPC
x 1 AddrBusPC WriteAH IncrementPC
x 2 AddrBusPC WriteAL IncrementPC
x 3 NextInstruction

# Store immediate word into B
[0x61] LDI_B @word
x 0 IncrementPC
x 1 AddrBusPC WriteBH IncrementPC
x 2 AddrBusPC WriteBL IncrementPC
x 3 NextInstruction

# Store immediate byte into AH
[0x62] LDI_AH $byte
x 0 IncrementPC
x 1 AddrBusPC WriteAH IncrementPC
x 2 NextInstruction

# Store immediate byte into AL
[0x63] LDI_AL $byte
x 0 IncrementPC
x 1 AddrBusPC WriteAL IncrementPC
x 2 NextInstruction

# Store immediate byte into BH
[0x64] LDI_BH $byte
x 0 IncrementPC
x 1 AddrBusPC WriteBH IncrementPC
x 2 NextInstruction

# Store immediate byte into AL
[0x65] LDI_BL $byte
x 0 IncrementPC
x 1 AddrBusPC WriteBL IncrementPC
x 2 NextInstruction

# Load from RAM into AH
[0x66] LD_AH @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteAH
x 4 NextInstruction

# Load from RAM into AL
[0x67] LD_AL @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteAL
x 4 NextInstruction

# Load from RAM into BH
[0x68] LD_BH @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteBH
x 4 NextInstruction

# Load from RAM into BL
[0x69] LD_BL @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteBL
x 4 NextInstruction

# Load from RAM@A into BH
[0x6a] LDA_BH
x 0 IncrementPC AddrBusA WriteBH
x 1 NextInstruction

# Load from RAM@A into BL
[0x6b] LDA_BL
x 0 IncrementPC AddrBusA WriteBL
x 1 NextInstruction

# Load from RAM@B into AH
[0x6c] LDB_AH
x 0 IncrementPC AddrBusB WriteAH
x 1 NextInstruction

# Load from RAM@B into AL
[0x6d] LDB_AL
x 0 IncrementPC AddrBusB WriteAL
x 1 NextInstruction

# Store AH into RAM@B

# Store AL into RAM@B

# Store BH into RAM@A

# Store BL into RAM@A


### ALU operations have the following format for $op
### bits 4-0 (mask 0x1f) = 5-bit opcode
### bit  5   (mask 0x20) = carry-in bit
### bit  6   (mask 0x40) = A bus hi(1)/lo(0)
### bit  7   (mask 0x80) = B bus hi(1)/lo(0)

# set flags only (do not store result)
[0x74] ALUOP_STATUS $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 WriteStatus NextInstruction

# store ALU result in TD
[0x75] ALUOP_TD $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteTD WriteStatus
x 3 NextInstruction

# store ALU result in TAH
[0x76] ALUOP_TAH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteTAH WriteStatus
x 3 NextInstruction

# store ALU result in TAL
[0x77] ALUOP_TAL $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteTAL WriteStatus
x 3 NextInstruction

# store ALU result in AH
[0x78] ALUOP_AH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteAH WriteStatus
x 3 NextInstruction

# store ALU result in AL
[0x79] ALUOP_AL $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteAL WriteStatus
x 3 NextInstruction

# store ALU result in BH
[0x7a] ALUOP_BH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteBH WriteStatus
x 3 NextInstruction

# store ALU result in BL
[0x7b] ALUOP_BL $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteBL WriteStatus
x 3 NextInstruction

# store ALU result in RAM at @addr
[0x7c] ALUOP_ADDR $op @addr
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to high byte of target address
x 2 AddrBusPC WriteTAH IncrementPC
x 3 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 4 DataBusALU AddrBusTA WriteRAM WriteStatus
x 5 NextInstruction

# store ALU result in RAM at A addr
[0x7d] ALUOP_ADDR_A $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU AddrBusA WriteRAM WriteStatus
x 3 NextInstruction

# store ALU result in RAM at B addr
[0x7e] ALUOP_ADDR_B $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU AddrBusB WriteRAM WriteStatus
x 3 NextInstruction

# push ALU result onto stack
[0x7f] ALUOP_PUSH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC IncrementSP
# PC now points to next instruction
x 2 DataBusALU AddrBusSP WriteRAM WriteStatus
x 3 NextInstruction

