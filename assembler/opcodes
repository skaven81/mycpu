# [opcode] NAME <arguments> - @arg = 16bit $arg = 8bit
#   opcode is the hexadecimal opcode, 0x00 - 0xff
#   NAME is the assembler name
#   arguments is a list of expected bytes after the opcode in the program,
#   @arg represents a 16-bit value (2 bytes), $arg represents an 8-bit
#   value (1 byte).
#
#   The microcode is written as a series of control sequences.  Each line
#   starts with one or two characters, (x,e,E,z,Z,f,F) that indicate that this
#   microcode entry should be executed for any flags (x), when the equal
#   flag is set (E) or clear (e), or the zero flag is set (Z) or clear (z),
#   or the overflow flag is set (F) or clear (f), or a combination (eZ, ZE),
#   etc.  A missing character means its value does not matter.  If neither
#   e nor z nor f matter, then "x" is a stand-in for "no status bits matter".
#
#   After this comes the sequence number,
#   from 0-f.  After this is a list of macros that will be
#   ORed to form the control signals for this microcode entry.

###### Phase 1 ######
# Program counter
# ROM (0x0000-0x3fff)
# RAM (0x4000-0xbfff)
# Opcode register + Status register + Sequence counter 
# Transfer registers
# Control ROMs

# No-op: does nothing
[0x00] NOP
x 0 IncrementPC 
x 1 NextInstruction

# Halt: goes into infinite loop of loading the program
# counter address into the opcode register, but never
# incrementing the program counter.  So the CPU just
# runs HLT in an endless loop.
[0xff] HLT
x 0 NextInstruction

# Store to RAM: store the specified byte at
# the given address.
[0x10] ST @addr $data
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to data byte
x 3 AddrBusPC WriteTD IncrementPC
x 4 AddrBusTA DataBusTD WriteRAM
x 5 NextInstruction

# Store to RAM from TD register
[0x11] ST_TD @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA DataBusTD WriteRAM
x 4 NextInstruction

# Load from RAM to TD register
[0x20] LD_TD @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteTD
x 4 NextInstruction

# Jump: unconditional jump to specified address
[0x30] JMP @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
x 2 AddrBusPC WritePCL
x 3 DataBusTD WritePCH
x 4 NextInstruction

# Push: put a static value on the stack
[0x40] PUSH $data
x 0 IncrementPC IncrementSP
# PC now points to data; SP points to target address
x 1 AddrBusPC WriteTD
# TD now contains the data to be written to the stack
x 2 AddrBusSP DataBusTD WriteRAM IncrementPC
# PC now points to next instruction
x 3 NextInstruction

# Push TD onto the stack
[0x41] PUSH_TD
x 0 IncrementPC IncrementSP
# PC now points to next instruction; SP points to target address
x 1 AddrBusSP DataBusTD WriteRAM # write TD to stack
x 2 NextInstruction

# Peek: fetch the data from the top of the stack
# into TD, but don't remove it
[0x48] PEEK_TD
x 0 AddrBusSP WriteTD IncrementPC
x 1 NextInstruction

# Pop into TD
[0x49] POP_TD
x 0 AddrBusSP WriteTD DecrementSP IncrementPC
x 1 NextInstruction

# Call subroutine: push next instruction address onto
# the stack, then jump to the given address
[0x50] CALL @addr
x 0 IncrementPC
# PC now points to high byte of subroutine address;
# Write high byte to TAL (TAL can present to data bus)
x 1 AddrBusPC WriteTAL IncrementPC
# PC now points to low byte of subroute address;
# Write low byte to TD
x 2 AddrBusPC WriteTD IncrementPC IncrementSP
# PC now points to next instruction address;
# Write low byte to stack
x 3 AddrBusSP DataBusPCL WriteRAM IncrementSP
# Write high byte to stack
x 4 AddrBusSP DataBusPCH WriteRAM
# Load next instruction address from TAL & TD
x 5 DataBusTAL WritePCH
x 6 DataBusTD WritePCL
x 7 NextInstruction

# Return from subroutine: pop the next instruction
# address from the stack, jump to that address
[0x5f] RET
x 0 AddrBusSP WritePCH DecrementSP
x 1 AddrBusSP WritePCL DecrementSP
x 2 NextInstruction


