# [opcode] NAME <arguments> - @arg = 16bit $arg = 8bit
#   opcode is the hexadecimal opcode, 0x00 - 0xff
#   NAME is the assembler name
#   arguments is a list of expected bytes after the opcode in the program,
#   @arg represents a 16-bit value (2 bytes), $arg represents an 8-bit
#   value (1 byte).
#
#   The microcode is written as a series of control sequences.  Each line
#   starts with one or two characters, (x,e,E,z,Z,o,O) that indicate that this
#   microcode entry should be executed for any flags (x), when the equal
#   flag is set (E) or clear (e), or the zero flag is set (Z) or clear (z),
#   or the overflow flag is set (O) or clear (o), or a combination (eZ, ZE),
#   etc.  A missing character means its value does not matter.  If neither
#   e nor z nor o matter, then "x" is a stand-in for "no status bits matter".
#
#   After this comes the sequence number,
#   from 0-f.  After this is a list of macros that will be
#   ORed to form the control signals for this microcode entry.

# No-op: does nothing
[0x00] NOP
x 0 IncrementPC 
x 1 NextInstruction

# Halt: goes into infinite loop of loading the program
# counter address into the opcode register, but never
# incrementing the program counter.  So the CPU just
# runs HLT in an endless loop.
[0xff] HLT
x 0 NextInstruction

# Store to RAM: store the specified byte at
# the given address.
[0x10] ST @addr $data
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to data byte
x 3 AddrBusPC WriteTD IncrementPC
x 4 AddrBusTA DataBusTD WriteRAM
x 5 NextInstruction

# Store to RAM from TD register
[0x11] ST_TD @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA DataBusTD WriteRAM
x 4 NextInstruction

# Load from RAM to TD register
[0x20] LD_TD @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteTD
x 4 NextInstruction

# Jump: unconditional jump to specified address
[0x30] JMP @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
x 2 AddrBusPC WritePCL
x 3 DataBusTD WritePCH
x 4 NextInstruction

# Jump if equal: jump to address if equal flag is set
[0x31] JEQ @addr
x 0 IncrementPC
e 1 IncrementPC # skip over high @addr byte
e 2 IncrementPC # skip over low @addr byte
e 3 NextInstruction
# PC now points to high byte of target address
E 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
E 2 AddrBusPC WritePCL
E 3 DataBusTD WritePCH
E 4 NextInstruction

# Jump if not equal: jump to address if equal flag is unset
[0x32] JNE @addr
x 0 IncrementPC
E 1 IncrementPC # skip over high @addr byte
E 2 IncrementPC # skip over low @addr byte
E 3 NextInstruction
# PC now points to high byte of target address
e 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
e 2 AddrBusPC WritePCL
e 3 DataBusTD WritePCH
e 4 NextInstruction

# Jump if zero: jump to address if zero flag is set
[0x33] JZ @addr
x 0 IncrementPC
z 1 IncrementPC # skip over high @addr byte
z 2 IncrementPC # skip over low @addr byte
z 3 NextInstruction
# PC now points to high byte of target address
Z 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
Z 2 AddrBusPC WritePCL
Z 3 DataBusTD WritePCH
Z 4 NextInstruction

# Jump if not zero: jump to address if zero flag is unset
[0x34] JNZ @addr
x 0 IncrementPC
Z 1 IncrementPC # skip over high @addr byte
Z 2 IncrementPC # skip over low @addr byte
Z 3 NextInstruction
# PC now points to high byte of target address
z 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
z 2 AddrBusPC WritePCL
z 3 DataBusTD WritePCH
z 4 NextInstruction

# Jump if overflow: jump to address if overflow flag is set
[0x35] JO @addr
x 0 IncrementPC
o 1 IncrementPC # skip over high @addr byte
o 2 IncrementPC # skip over low @addr byte
o 3 NextInstruction
# PC now points to high byte of target address
O 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
O 2 AddrBusPC WritePCL
O 3 DataBusTD WritePCH
O 4 NextInstruction

# Jump if not overflow: jump to address if overflow flag is unset
[0x36] JNO @addr
x 0 IncrementPC
O 1 IncrementPC # skip over high @addr byte
O 2 IncrementPC # skip over low @addr byte
O 3 NextInstruction
# PC now points to high byte of target address
o 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
o 2 AddrBusPC WritePCL
o 3 DataBusTD WritePCH
o 4 NextInstruction

# Jump if equal and not overflow: jump to address if equal flag is set and overflow flag is unset
[0x37] JEQ_SAFE @addr
x 0 IncrementPC
e 1 IncrementPC # skip over high @addr byte
e 2 IncrementPC # skip over low @addr byte
e 3 NextInstruction
# PC now points to high byte of target address
Eo 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
Eo 2 AddrBusPC WritePCL
Eo 3 DataBusTD WritePCH
Eo 4 NextInstruction

# Jump if not equal and not overflow: jump to address if equal flag is unset and overflow flag is unset
[0x38] JNE_SAFE @addr
x 0 IncrementPC
E 1 IncrementPC # skip over high @addr byte
E 2 IncrementPC # skip over low @addr byte
E 3 NextInstruction
# PC now points to high byte of target address
eo 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
eo 2 AddrBusPC WritePCL
eo 3 DataBusTD WritePCH
eo 4 NextInstruction

# Jump if zero and not overflow: jump to address if zero flag is set and overflow flag is unset
[0x39] JZ_SAFE @addr
x 0 IncrementPC
z 1 IncrementPC # skip over high @addr byte
z 2 IncrementPC # skip over low @addr byte
z 3 NextInstruction
# PC now points to high byte of target address
Zo 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
Zo 2 AddrBusPC WritePCL
Zo 3 DataBusTD WritePCH
Zo 4 NextInstruction

# Jump if not zero and not overflow: jump to address if zero flag is unset and overflow flag is unset
[0x3a] JNZ_SAFE @addr
x 0 IncrementPC
Z 1 IncrementPC # skip over high @addr byte
Z 2 IncrementPC # skip over low @addr byte
Z 3 NextInstruction
# PC now points to high byte of target address
zo 1 AddrBusPC WriteTD IncrementPC
# TD now contains high byte of target address and
# PC points to low byte of target address
zo 2 AddrBusPC WritePCL
zo 3 DataBusTD WritePCH
zo 4 NextInstruction

# Push: put a static value on the stack
[0x40] PUSH $data
x 0 IncrementPC IncrementSP
# PC now points to data; SP points to target address
x 1 AddrBusPC WriteTD
# TD now contains the data to be written to the stack
x 2 AddrBusSP DataBusTD WriteRAM IncrementPC
# PC now points to next instruction
x 3 NextInstruction

# Push TD onto the stack
[0x41] PUSH_TD
x 0 IncrementPC IncrementSP
# PC now points to next instruction; SP points to target address
x 1 AddrBusSP DataBusTD WriteRAM # write TD to stack
x 2 NextInstruction

# Peek: fetch the data from the top of the stack
# into TD, but don't remove it
[0x48] PEEK_TD
x 0 AddrBusSP WriteTD IncrementPC
x 1 NextInstruction

# Pop into TD
[0x49] POP_TD
x 0 AddrBusSP WriteTD DecrementSP IncrementPC
x 1 NextInstruction

# Call subroutine: push next instruction address onto
# the stack, then jump to the given address
[0x50] CALL @addr
x 0 IncrementPC
# PC now points to high byte of subroutine address;
# Write high byte to TAL (TAL can present to data bus)
x 1 AddrBusPC WriteTAL IncrementPC
# PC now points to low byte of subroute address;
# Write low byte to TD
x 2 AddrBusPC WriteTD IncrementPC IncrementSP
# PC now points to next instruction address;
# Write low byte to stack
x 3 AddrBusSP DataBusPCL WriteRAM IncrementSP
# Write high byte to stack
x 4 AddrBusSP DataBusPCH WriteRAM
# Load next instruction address from TAL & TD
x 5 DataBusTAL WritePCH
x 6 DataBusTD WritePCL
x 7 NextInstruction

# Return from subroutine: pop the next instruction
# address from the stack, jump to that address
[0x5f] RET
x 0 AddrBusSP WritePCH DecrementSP
x 1 AddrBusSP WritePCL DecrementSP
x 2 NextInstruction

# Store immediate word into A
[0x60] LDI_A @word
x 0 IncrementPC
x 1 AddrBusPC WriteAH IncrementPC
x 2 AddrBusPC WriteAL IncrementPC
x 3 NextInstruction

# Store immediate word into B
[0x61] LDI_B @word
x 0 IncrementPC
x 1 AddrBusPC WriteBH IncrementPC
x 2 AddrBusPC WriteBL IncrementPC
x 3 NextInstruction

# Store immediate byte into AH
[0x62] LDI_AH $byte
x 0 IncrementPC
x 1 AddrBusPC WriteAH IncrementPC
x 2 NextInstruction

# Store immediate byte into AL
[0x63] LDI_AL $byte
x 0 IncrementPC
x 1 AddrBusPC WriteAL IncrementPC
x 2 NextInstruction

# Store immediate byte into BH
[0x64] LDI_BH $byte
x 0 IncrementPC
x 1 AddrBusPC WriteBH IncrementPC
x 2 NextInstruction

# Store immediate byte into AL
[0x65] LDI_BL $byte
x 0 IncrementPC
x 1 AddrBusPC WriteBL IncrementPC
x 2 NextInstruction

# Load from RAM into AH
[0x66] LD_AH @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteAH
x 4 NextInstruction

# Load from RAM into AL
[0x67] LD_AL @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteAL
x 4 NextInstruction

# Load from RAM into BH
[0x68] LD_BH @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteBH
x 4 NextInstruction

# Load from RAM into BL
[0x69] LD_BL @addr
x 0 IncrementPC
# PC now points to high byte of target address
x 1 AddrBusPC WriteTAH IncrementPC
x 2 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 3 AddrBusTA WriteBL
x 4 NextInstruction

# Load from RAM@A into BH
[0x6a] LDA_BH
x 0 IncrementPC AddrBusA WriteBH
x 1 NextInstruction

# Load from RAM@A into BL
[0x6b] LDA_BL
x 0 IncrementPC AddrBusA WriteBL
x 1 NextInstruction

# Load from RAM@B into AH
[0x6c] LDB_AH
x 0 IncrementPC AddrBusB WriteAH
x 1 NextInstruction

# Load from RAM@B into AL
[0x6d] LDB_AL
x 0 IncrementPC AddrBusB WriteAL
x 1 NextInstruction

# Store ALU Data Bus into RAM@A
[0x6e] ST_ALU_ADDR_A
x 0 IncrementPC AddrBusA DataBusALU WriteRAM
x 1 NextInstruction

# Store ALU Data Bus into RAM@B
[0x6f] ST_ALU_ADDR_B
x 0 IncrementPC AddrBusB DataBusALU WriteRAM
x 1 NextInstruction

# Store TD into RAM@A
[0x70] ST_TD_ADDR_A
x 0 IncrementPC AddrBusA DataBusTD WriteRAM
x 1 NextInstruction

# Store TD into RAM@B
[0x71] ST_TD_ADDR_B
x 0 IncrementPC AddrBusB DataBusTD WriteRAM
x 1 NextInstruction

# Store TAL into RAM@A
[0x72] ST_TAL_ADDR_A
x 0 IncrementPC AddrBusA DataBusTAL WriteRAM
x 1 NextInstruction

# Store TAL into RAM@B
[0x73] ST_TAL_ADDR_B
x 0 IncrementPC AddrBusB DataBusTAL WriteRAM
x 1 NextInstruction

### ALU operations have the following format for $op
### bits 4-0 (mask 0x1f) = 5-bit opcode
### bit  5   (mask 0x20) = carry-in bit
### bit  6   (mask 0x40) = A bus hi(1)/lo(0)
### bit  7   (mask 0x80) = B bus hi(1)/lo(0)

# set flags only (do not store result)
[0x74] ALUOP_FLAGS $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 WriteStatus NextInstruction

# store ALU result in TD
[0x75] ALUOP_TD $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteTD WriteStatus
x 3 NextInstruction

# store ALU result in TAH
[0x76] ALUOP_TAH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteTAH WriteStatus
x 3 NextInstruction

# store ALU result in TAL
[0x77] ALUOP_TAL $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteTAL WriteStatus
x 3 NextInstruction

# store ALU result in AH
[0x78] ALUOP_AH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteAH WriteStatus
x 3 NextInstruction

# store ALU result in AL
[0x79] ALUOP_AL $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteAL WriteStatus
x 3 NextInstruction

# store ALU result in BH
[0x7a] ALUOP_BH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteBH WriteStatus
x 3 NextInstruction

# store ALU result in BL
[0x7b] ALUOP_BL $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU WriteBL WriteStatus
x 3 NextInstruction

# store ALU result in RAM at @addr
[0x7c] ALUOP_ADDR $op @addr
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to high byte of target address
x 2 AddrBusPC WriteTAH IncrementPC
x 3 AddrBusPC WriteTAL IncrementPC
# PC now points to next instruction
x 4 DataBusALU AddrBusTA WriteRAM WriteStatus
x 5 NextInstruction

# store ALU result in RAM at A addr
[0x7d] ALUOP_ADDR_A $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU AddrBusA WriteRAM WriteStatus
x 3 NextInstruction

# store ALU result in RAM at B addr
[0x7e] ALUOP_ADDR_B $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC
# PC now points to next instruction
x 2 DataBusALU AddrBusB WriteRAM WriteStatus
x 3 NextInstruction

# push ALU result onto stack
[0x7f] ALUOP_PUSH $op
x 0 IncrementPC
# PC now points to $op
x 1 AddrBusPC WriteALUop IncrementPC IncrementSP
# PC now points to next instruction
x 2 DataBusALU AddrBusSP WriteRAM WriteStatus
x 3 NextInstruction

