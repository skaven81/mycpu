# Transfer operations
MOV_CH_{AH,AL,BH,BL,TAL,TD}
MOV_CL_{AH,AL,BH,BL,TAL,TD}
MOV_DH_{AH,AL,BH,BL,TAL,TD}
MOV_DL_{AH,AL,BH,BL,TAL,TD}

# Push $data onto stack
PUSH $data  ** TD **
# Push {reg} onto stack
PUSH_{CH,CL,DH,DL}
# Peek/Pop into {reg}
{PEEK,POP}_{AH,AL,BH,BL,CH,CL,DH,DL,TAL,TD}

# To MOV or PUSH from AH,AL,BH,BL to another register
# or the stack, use an ALUOP_{reg} or ALUOP_PUSH operation
# with the desired A/B register as the source configured
# in the ALU op.

# Store $data at @addr
ST @addr $data  ** TAH TAL TD **

# Store {reg} at @addr
ST_{CH,CL,DH,DL,TD} @addr   ** TAH TAL **

# Load RAM@addr into {reg}
LD_{AH,AL,BH,BL,CH,CL,DH,DL,TD} @addr   ** TAH TAL **

# Load @word into {reg}
LDI_{A,B,C,D} @word
# Load $byte into {reg}
LDI_{AH,AL,BH,BL,CH,CL,DH,DL,TAL,TD} $byte

# Load RAM@{addr_reg} into {reg}
LDA_A_{BH,BL,CH,CL,DH,DL,TAL,TD}
LDA_B_{AH,AL,CH,CL,DH,DL,TAL,TD}
LDA_C_{AH,AL,BH,BL,TAL,TD}
LDA_D_{AH,AL,BH,BL,TAL,TD}

# Store into RAM@{addr_reg} from {reg}
STA_A_{CH,CL,DH,DL,TAL,TD}  ** TAH TAL **
STA_B_{CH,CL,DH,DL,TAL,TD}
STA_C_{DH,DL,TD}
STA_D_{CH,CL,TD}

# Jumps - all also have _D variant
JMP @addr   ** TD **
JEQ @addr   ** TD **
JNE @addr   ** TD **
JZ @addr    ** TD **
JNZ @addr   ** TD **
JO @addr    ** TD **
JNO @addr   ** TD **

JMP_D @addr
JEQ_D @addr
JNE_D @addr
JZ_D @addr
JNZ_D @addr
JO_D @addr
JNO_D @addr

# ALU operations
ALUOP_FLAGS $op
ALUOP_PUSH $op
ALUOP_ADDR $op @addr    ** TAH TAL **
# Store ALU result into RAM@{addr_reg}
ALUOP_ADDR_{A,B,C,D} $op
# Store ALU result into {reg}
ALUOP_{AH,AL,BH,BL,CH,CL,DH,DL,TAL,TD} $op

# General purpose
NOP
HLT
CALL @addr  ** TAL TD **
RET
IRQ
RETI
MASKINT
UMASKINT
INCR_C
DECR_C
INCR_D
DECR_D

# Load the IRQ base address into a register
IRQBASE_{AH,AL,BH,BL,CH,CL,DH,DL}
# Load the IRQ ID (shifted left one) into a register
IRQID_{AH,AL,BH,BL,CH,CL,DH,DL}
# Load the contents of the status register into a register
STATUS_{AH,AL,BH,BL,CH,CL,DH,DL}

# Timer rates
0x0 1/2 sec
0x1 1/4 sec
0x2 1/8 sec
0x3 1/16 sec
0x4 1/32 sec
0x5 1/64 sec
0x6 1/128 sec
0x7 1/256 sec

# Memory ranges
0x0000 - 0x3eff program data (ROM)
0x4000 - 0x4eff framebuffer chars
0x4f00 - 0x4fff hidden framebuffer (global vars)
0x5000 - 0x5eff framebuffer color
0x5f00 - 0x5f0f interrupt addresses
0x5f10 - 0x5fff hidden framebuffer (global vars)
0x6000 - 0xbeff RAM
0xbf00 - 0xbfff stack
0xc000 - 0xffff peripherals

# Interrupt handling
When CPU comes out of reset, IRQMASK will be set.  In order to take advantage
of interrupts, IRQ handler addresses must be loaded into the following memory
locations.  The first byte is 0x5f, the second byte is the IRQ number, shifted
left one place (so a 16-bit address can be placed at each location):

 * IRQ0 0x5f00
 * IRQ1 0x5f02
 * IRQ2 0x5f04
 * IRQ3 0x5f06
 * IRQ4 0x5f08
 * IRQ5 0x5f0a
 * IRQ6 0x5f0c
 * IRQ7 0x5f0e

The IRQ opcode saves the PC onto the stack, then loads 0x5f into DH and the
IRQ ID (shifted left) into DL.  This address is loaded into PCH.  Then D is
incremented and that address is loaded into PCL and the CPU begins executing
at that new address.

The interrupt handler calls RETI when it is done, instead of the usual RET.

The interrupt handler is responsible for leaving the CPU in the same state
as when it was called.

