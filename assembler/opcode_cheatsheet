# Variable declaration
VAR {global,local} {byte,word} $name

# Transfer operations
MOV_CH_{AH,AL,BH,BL,TAL,TD}
MOV_CL_{AH,AL,BH,BL,TAL,TD}
MOV_DH_{AH,AL,BH,BL,TAL,TD}
MOV_DL_{AH,AL,BH,BL,TAL,TD}

# Push $data onto stack
PUSH $data  ** TD **
# Push {reg} onto stack
PUSH_{CH,CL,DH,DL}
# Peek/Pop into {reg}
{PEEK,POP}_{AH,AL,BH,BL,CH,CL,DH,DL,TAL,TD}

# To MOV or PUSH from AH,AL,BH,BL to another register
# or the stack, use an ALUOP_{reg} or ALUOP_PUSH operation
# with the desired A/B register as the source configured
# in the ALU op.

# Store $data at @addr
ST @addr $data  ** TAH TAL TD **

# Store 16-bit @data at @addr (overwrites D reg)
ST16 @addr @data ** TD **

# Store {reg} at @addr
ST_{CH,CL,DH,DL,TD} @addr   ** TAH TAL **

# Store into RAM@{addr_reg} from {reg}
STA_A_{CH,CL,DH,DL,TAL,TD}  ** TAH TAL **
STA_B_{CH,CL,DH,DL,TAL,TD}
STA_C_{DH,DL,TD}
STA_D_{CH,CL,TD}

# Load RAM@addr into {reg}
LD_{AH,AL,BH,BL,CH,CL,DH,DL,TD} @addr   ** TAH TAL **

# Load 16-bit word at @addr into A or B. Use separate
# LD_* instructions for C and D.  LD16 takes 10 clocks;
# LD takes 5, so there is no performance difference.
LD16_{A,B} @addr

# Load @word into {reg}
LDI_{A,B,C,D} @word
# Load $byte into {reg}
LDI_{AH,AL,BH,BL,CH,CL,DH,DL,TAL,TD} $byte

# Load RAM@{addr_reg} into {reg}
LDA_A_{BH,BL,CH,CL,DH,DL,TAL,TD}
LDA_B_{AH,AL,CH,CL,DH,DL,TAL,TD}
LDA_C_{AH,AL,BH,BL,TAL,TD}
LDA_D_{AH,AL,BH,BL,TAL,TD}

# Jumps to fixed address
JMP @addr   ** TD **
JEQ @addr   ** TD **
JNE @addr   ** TD **
JZ @addr    ** TD **
JNZ @addr   ** TD **
JO @addr    ** TD **
JNO @addr   ** TD **

# Jumps to address in D register
JMP_D
JEQ_D
JNE_D
JZ_D
JNZ_D
JO_D
JNO_D

# ALU operations
ALUOP_FLAGS $op
ALUOP_PUSH $op
ALUOP_ADDR $op @addr    ** TAH TAL **
# Store ALU result into RAM@{addr_reg}
ALUOP_ADDR_{A,B,C,D} $op
# Store ALU result into {reg}
ALUOP_{AH,AL,BH,BL,CH,CL,DH,DL,TAL,TD} $op

# General purpose
NOP
HLT
CALL @addr  ** TAL TD **
RET
IRQ
RETI
MASKINT
UMASKINT
INCR_C
DECR_C
INCR_D
DECR_D

# Load the IRQ base address into a register
IRQBASE_{AH,AL,BH,BL,CH,CL,DH,DL}
# Load the IRQ ID (shifted left one) into a register
IRQID_{AH,AL,BH,BL,CH,CL,DH,DL}
# Load the contents of the status register into a register
STATUS_{AH,AL,BH,BL,CH,CL,DH,DL}

# Color byte masks
0x03 blue   xx xx xx 11
0x0c green  xx xx 11 xx
0x30 red    xx 11 xx xx
0x40 cursor x1 xx xx xx
0x80 blink  1x xx xx xx

# Memory ranges
0x0000 - 0x3eff program data (ROM)
0x4000 - 0x4eff framebuffer chars
0x4f00 - 0x4fff hidden framebuffer (local asm vars)
0x5000 - 0x5eff framebuffer color
0x5f00 - 0x5f0f interrupt addresses
0x5f10 - 0x5fff hidden framebuffer (global asm vars)
0x6000 - 0xbdff RAM
0xba00 - 0xbdff heap (lib/heap.asm)
0xbe00 - 0xbeff keyboard buffer (lib/keyboard.asm)
0xbf00 - 0xbfff CPU stack
0xc000 - 0xffff peripherals

# Interrupt handling
When CPU comes out of reset, IRQMASK will be set.  In order to take advantage
of interrupts, IRQ handler addresses must be loaded into the following memory
locations.  The first byte is 0x5f, the second byte is the IRQ number, shifted
left one place (so a 16-bit address can be placed at each location):

 * IRQ0 0x5f00
 * IRQ1 0x5f02
 * IRQ2 0x5f04
 * IRQ3 0x5f06
 * IRQ4 0x5f08
 * IRQ5 0x5f0a
 * IRQ6 0x5f0c
 * IRQ7 0x5f0e

The IRQ opcode saves the PC onto the stack, then loads 0x5f into DH and the
IRQ ID (shifted left) into DL.  This address is loaded into PCH.  Then D is
incremented and that address is loaded into PCL and the CPU begins executing
at that new address.

The interrupt handler calls RETI when it is done, instead of the usual RET.

The interrupt handler is responsible for leaving the CPU in the same state
as when it was called.

